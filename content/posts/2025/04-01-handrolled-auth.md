---
title: "Handrolled Authentication Service"
date: 2025-02-04
slug: /handrolled-auth/
description: An exploration into handrolling my own authentication system, including session management
image: /images/handrolled-auth/thumbnail.webp
caption: Image generated by DALL.E
categories:
  - coding
  - from-scratch
tags:
  - http
  - authentication
  - jwt
  - tokens
  - cookies
  - coding
  - rust
  - solidjs
  - typescript
draft: false
---

# Introduction

<a class="flex h-min items-center space-x-3" href="https://github.com/jacob-horton/handrolled-auth" target="_blank" rel="noopener">
    <img class="!my-0 w-8 h-8" src="/icons/github.svg" />
    <p class="!my-0">Code</p>
</a>

In this blog, I continue the series of making things from scratch - learning how to handroll my own authentication service. The aim of this project was to learn how a typical authentication flow works and create a simple demo to be able to refer back to in the future. I explored methods to handle authentication and get around drawbacks, landing on a very common authentication pattern - using access and refresh JWTs.

> Please do not take this as security advice - **only handroll your own authentication service if you know what you are doing**.


# The Problem

I wanted to create a working login system where the users can stay logged in for extended periods of time. This requires addressing two problems:
- **Authentication** - checking the credentials of the user to ensure they are who they say they are. Their credentials can be their username and password, or some other form of identification such as a session token
- **Session management** - keeping track of the users that are logged in, ensuring they stay logged in even after closing and reopening their browser


# Authentication Flow

The typical flow of an authentication system is as follows:

1. The user enters their username and password on the client side
2. These credentials are sent to the server to be validated
3. The server checks if the credentials are valid, and if they are, it will return some kind of unique token for that session
4. The client stores this token and sends it in any future request that requires authentication. This way, we don't need the user's username and password on every network request

![Authentication flow diagram](/images/handrolled-auth/auth-flow.svg)


# Initial Authentication

The focus of this project was not on validating usernames and passwords, but here is a brief overview of my setup:
- I have a list of user records on the server
- Each record contains the user's details including their username and their (salted and hashed) password
- When the client sends the username and password, the user with the provided username is found, and the password is checked

> For more information on securely storing passwords, including salting and hashing, [see here](https://www.vaadata.com/blog/how-to-securely-store-passwords-in-database/).


# Session Management

We have several ways we can manage sessions. Two popular methods are session tokens and JWTs (JSON Web Tokens). Both of these methods start with the client sending the username and password to the server, followed by the server validating the credentials. If they are valid, we move on to the next step, which is where sessions and JWTs differ.

## Sessions

The server typically creates a random 128-bit string as a unique ID for that session. This is stored in the database along with any extra information required about the session. It is also sent to the client, who stores it in a cookie to use in future requests.

On each request, the server will check if the session ID (from the cookie) exists in the database, and is still valid. This makes invalidating sessions easy - deleting the session record from the database will prevent future requests from being authorised with the same token.

While this is really simple and has a lot of flexibility, its stateful nature causes scalability issues. Before any request can be processed, there is the latency of reaching out to a database. It is also harder to distribute this system as the session database will need to be kept in sync across the distributed system.


## JWTs

JWTs are also tokens that are provided to the client to store and use in future requests. However, they solve the problem of sessions by being stateless - the validity of a JWT can be checked without having to do a database check. The JWT does this by storing "claims" - a set of requirements the token must pass for it to be valid. There are several common claims, but they typically include at least an expiration time, who issued the token, and the subject e.g. the user ID. All of this is signed by the server to ensure that the token must have come from a trusted source.

> More information:
>
> - [JWT structure](https://jwt.io/introduction)
> - [Digital signatures](https://en.wikipedia.org/wiki/Digital_signature)


To check that the JWT is valid, the server needs to check the signature, and then each of the claims. If everything passes, we know that the user has a valid session. The key is that these claims do not require database lookups, allowing them to be stateless.

> JWTs can be decoded by anyone, so should not include any secret data. The signature on the JWT only ensures that a trusted source has created it, and it has not been tampered with (e.g. no one has changed the user ID or expiration date).

However, we now have a new problem - how are we meant to invalidate a session when JWTs are stateless?


# Solving JWT's Biggest Problem

Being able to invalidate a session is really useful for many reasons, for example, if a user's permissions change, we need to invalidate the current token and give them a new one with the new permissions. With our current setup, we need to wait for the JWT to expire for the session to become invalid. To fix this, we could use a blacklist to invalidate the session early, but this means we would need a database lookup on every request. 

Instead, we can make the expiry time sooner, say 5 minutes. Therefore, after 5 minutes, the user has to re-authenticate with their username and password, allowing us to do extra checks and change any permissions. However, this is really inconvenient - no one wants to put their username and password in every 5 minutes. But there is a solution to this - **refresh tokens**! These allow us to keep the short expiry, without requiring the user's credentials often.

Refresh tokens are a long-living (e.g. 1 month) JWT that allows the user to request a new access token. We create this token at the same time as the original token, which we will now call the **access token**. When the access token expires, the client can use the refresh token to get a new access token. At this point, the server can do any extra checks or permission changes (checking the database if needed) before returning a new access token or refusing to do so. This has the benefit of keeping the access tokens stateless, and only requiring database checks a maximum of every 5 minutes.

Now, how do we invalidate sessions? The way I chose to do this is to store a version in a claim on the refresh token. This will match a version stored in our database. To invalidate a session, we just need to increment the version in our database. Then, when we come to check the claims of the refresh token, it will fail the version claim, forcing the user to re-authenticate. Problem solved!

> This does have a drawback - after invalidating the sessions, it may take up to 5 minutes (or the whatever lifespan of the access token is) for the user to be logged out.


# Storing JWTs

There are several ways to store JWTs on the client side, but the most secure way is using HTTP-only cookies. These are cookies that cannot be accessed with JavaScript, which reduces our attack surface.

To store an HTTP-only cookie, the server must return a header called `Set-Cookie` with a value in the format `<name>=<value>; HttpOnly`. This tells the client to save the cookie, which it can then use in requests in the following way:

```javascript
fetch("http://localhost:8080/endpoint", {
    // Include the HTTP-only cookies in the request
    credentials: "include",
});
```

> There are several other settings you'll probably want to configure for better cookie security. For example `Secure` only allows sending the cookie over HTTPS and `SameSite=Lax` only allows sending the cookie to the site it originated from. For more information, have a read of [MDN Set-Cookie docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) as well as the [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)

Using HTTP-only cookies, the client now no longer knows who it is logged in as - it cannot read the JWT. The way to solve this is to have an endpoint on the server for fetching the user information. Since the server can read the JWT, it will know the ID of the user that made the request, and then can return relevant information.


# Conclusion

And there we have it - a fully functioning authentication service, with session management and invalidation. Now you know the general flow of an authentication system, along with some of the problems they solve. If you would like to see some code, I have an example implementation of everything discussed [here](https://github.com/jacob-horton/handrolled-auth). This is written using the HTTP server I created in my previous post ([HTTP from scratch]({{< ref "01-02-http-from-scratch" >}})), and ended up being only a few hundred lines of code!

It is important to remember that this may not be the best or most secure way to handle authentication, and more research should be done if you wish to handroll your own auth in production. It is often recommended to just use a library or pre-existing auth service that is written by people who are well-experienced in security. Despite that, I still think it's really useful to learn how these services work at their core - that is the whole point of this "from scratch" series after all!


# Resources

- [JWTs vs Sessions](https://stytch.com/blog/jwts-vs-sessions-which-is-right-for-you/)
- [Ben Awad video on handrolling authentication](https://youtu.be/CcrgG5MjGOk?si=iUyYPSdDm2SV5uA5)
- [MDN Set-Cookie docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie)
- [JWT overview](https://jwt.io/introduction)
- [Digital signatures](https://en.wikipedia.org/wiki/Digital_signature)
- [Securely storing passwords](https://www.vaadata.com/blog/how-to-securely-store-passwords-in-database/)
- [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)
