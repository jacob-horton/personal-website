---
title: "HTTP From Scratch"
date: 2025-01-30
slug: /http-from-scratch/
description: An exploration into writing an HTTP server from scratch
image: images/http-server.webp
caption: Image generated by DALL.E
categories:
  - astronomy
tags:
  - from-scratch
  - http
  - tcp
  - feature
draft: true
---

# Introduction

After writing many HTTP servers using libraries, I realised I wanted to understand how these HTTP libraries work under the hood. So, I decided to make a bare-bones HTTP server from the ground up.

To make things easy, I decided to only look at HTTP/1.1, as this is text based and is built on TCP. Conveniently, this is also the format described in the [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages), which was my main resource in this project.


# HTTP Messages

HTTP is a messaging system - a message is sent to the server (the **request**), and the server responds with a message (the **response**). As mentioned before, HTTP/1.1 uses plain text messages, which are in a fixed format. Requests and responses have a very similar format:
- A start line
- The headers (1 per line)
- An empty line (to separate metadata from the body)
- An optional body

Each line is separated by `\r\n` (the line delimiter used in Windows).

The main difference between requests and responses is the start line:
- In the request, it includes the method, request target (path) and protocol version
- In the response, it includes the protocol version, status code and status text


# Server Setup

As HTTP is built on TCP, we need to set up a TCP listener:

```rust
let listener = TcpListener::bind("127.0.0.1:8080").unwrap();
```

Then, when a connection is made, we pass the TCP stream to a connection handler:

```rust
for stream in listener.incoming() {
    let stream = stream.unwrap();
    handle_connection(stream);
}
```

<!-- TODO: link to parsing requests -->
Next, we read the request from the stream (details in parsing requests):

```rust
let req = Request::from_reader(&mut stream);
```

<!-- TODO: link to generating responses -->
Finally, generate a response (details in generating responses) and write that to the TCP stream:

```rust
let resp = Response::new(Status::Ok);
stream.write_all(resp.to_string().as_bytes()).unwrap();
```


## Parsing Requests

TCP streams are difficult to work with - they are a constant stream of data, so at the point of reading, the data may not all be ready. We also need to know when the request ends (i.e. when to stop reading data), as there is no delimiter.

Each line in an HTTP request ends in `\r\n`. This makes parsing the metadata simple - we just need to read until the end of each line until we get an empty line.


### Request Line

<!-- TODO: reiterate format -->
First, the request line - we read the line, and split it into it's 3 parts (the method, path, and version):

```rust
// Set up reader and buffer
let mut buf_read = BufReader::new(stream);
let mut buf = String::new();

// Read the first line
buf_read.read_line(&mut buf).unwrap();

// Parse the first line
let mut parts = buf.split(" ");
let method = Method::from_str(parts.next().unwrap().trim()).unwrap();
let path = parts.next().unwrap().trim().to_string();
let version = parts.next().unwrap().trim().to_string();
```

I decided to only support the official status codes, which I represent with an enum, called `Method`. This means I need to convert from a string to a `Method` (using a simple match statement).

<!-- TODO: format notes properly -->
Note: here, I am using lots of `unwrap`s to keep the code simple. In an actual HTTP server, it should handle an incorrectly formatted HTTP request without crashing the server.

Note: I use trim to get rid of extra whitespace. This is necessary for the end of the line, as `read_line` reads until a `\n`, leaving the `\r` in the buffer. This may not exactly match the HTTP spec, but it works for my purposes.


### Headers

Now to read the headers, I loop until reaching an empty line. Headers are in the format `<name>: <value>`. This is how I parse the headers:

```rust
let mut headers = Vec::new();
while !buf.trim().is_empty() {
    let (name, value) = buf.split_once(":").unwrap();
    headers.push(Header {
        name: name.trim().to_owned(),
        value: value.trim().to_owned(),
    });

    buf.clear();
    buf_read.read_line(&mut buf).unwrap();
}
```

Note: I have stored these in a `Vec` instead of a `HashMap` or `BTreeMap` as sometimes we have multiple headers with the same name (e.g. `Set-Cookie`)


### Body

For my purposes, I have assumed that all requests with a body have a `Content-Length` header. If the header is missing, I do not read a body.

The `Content-Length` tells us the number of bytes of the body. This makes it really easy to read the rest of it - we just read a fixed number of bytes:
```rust
// Read body if there is one
let mut body = None;
if let Some(length) = headers
    .iter()
    .find(|h| h.name.to_lowercase() == "content-length")
{
    let length: usize = length.value.parse().unwrap();

    if length > 0 {
        // Read the entire length of the body
        let mut buf = vec![0; length];
        buf_read.read_exact(&mut buf).unwrap();

        // Convert ot a string
        let body_str = String::from_utf8(buf).unwrap();
        body = Some(body_str.trim().to_owned());
    }
}
```

And just like that we've parsed the entire request!


## Generating Responses

Now to send a response. I have a simple struct to store the response data:

```rust
#[derive(Debug, Clone)]
pub struct Response {
    pub version: String,
    pub status_code: Status,
    pub headers: Vec<Header>,
    pub body: Option<String>,
}
```

I also have some helper/builder functions to make instantiating it easier.

All that needs to be done is converting this struct into a string in the format of an HTTP response:

```rust
let mut result = String::new();

// First line of response
result.push_str(&self.version);
result.push_str(" ");
result.push_str(&self.status_code.to_string());
result.push_str("\r\n");

// Headers
for header in &self.headers {
    // Content-Length is calculated and added later, skip if manually defined
    if header.name.to_lowercase() == "content-length" {
        continue;
    }

    result.push_str(&header.name.to_string());
    result.push_str(": ");
    result.push_str(&header.value.to_string());
    result.push_str("\r\n");
}

if let Some(body) = &self.body {
    // If there is a body, add the Content-Length header with its length
    result.push_str("Content-Length: ");
    result.push_str(&body.len().to_string());

    // Add an empty line followed by the body
    result.push_str("\r\n\r\n");
    result.push_str(body);
} else {
    // If there isn't a body, the content length is 0
    result.push_str("Content-Length: 0");
}
```

And that's all there is to it - the HTTP server now has everything we need to work!

# Cookies

Cookies are sent in headers - they are just a header in a particular format (`<cookie1_name>=<cookie1_value>; <cookie2_name>=<cookie2_value> ...`). Although not necessary, I decided to make the server more useful by parsing the cookies for easy access.


Here, we read all `cookie` headers (in case there are multiple), and read all the cookies in each header:

```rust
let mut cookies = Vec::new();
for header in &headers {
    if header.name.to_lowercase() == "cookie" {
        for cookie in header.value.split(";") {
            let (name, value) = cookie.split_once("=").expect("Invalid cookie");
            cookies.push(Cookie {
                name: name.trim().to_string(),
                value: value.trim().to_string(),
            })
        }
    }
}
```

# Routing

We have everything we need for an HTTP server now, but most of the time we want to call different functions based on the HTTP method and path (an **endpoint**). A naive approach would be to use an `if` statement per endpoint, but this does not scale well. Instead, we can create a router which stores all the possible endpoints and the function they map to.


# Missing Features

<!-- TODO: -->
- HTTP versions
- Multi-part requests
- Parallelism


# Resources

- [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages)
